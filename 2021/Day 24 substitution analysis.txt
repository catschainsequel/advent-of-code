Substitution code v1:
A: (((((X0+8)*26)+(X1+11))*26)+(X2+2))
// Note that we can remove everything but X2+2 when this is % 26, and everything but the first part when this is / 26.
B: ((A/26)*((25*((((A%26)+-10)==X3)==0))+1))
C: ((((B+((X3+11)*((((A%26)+-10)==X3)==0)))*26)+(X4+1))%26)

=====================================
Substitution code v2:
A: ((((X0+8)*26)+(X1+11))*((25*((((X2+2)+-10)==X3)==0))+1))
// ((((X0+8)*26)+(X1+11))*(26 or 1)) > 1
// ((((X0+8)*26)+(X1+11))*((25*((((X2-8)==X3)==0))+1))
// r2 = X0+8, r1 = X1+11
// if (X2 != X3 + 8) shift r2, r1 left (to r3, r2)

B: ((X3+11)*((((X2+2)+-10)==X3)==0))
// ((X3+11)*(1 or 0)) >= 0
// if (X2 != X3 + 8) r1 = X3+11

C: ((25*((((X4+1)+-3)==X5)==0))+1)
// 26 or 1
// ((25*((((X4-2)==X5)==0))+1)
// if (X4 != X5 + 2), 26, else 1

D: ((X5+5)*((((X4+1)+-3)==X5)==0))
// Note that these 0 comparisons to products are really checking if one of the other products is 0, so we can optimize these out too.
// >= 0
// if (X4 != X5 + 2), X5+5

E': (((A+B)*C)+D)

E: ((X6+10)*((((E'%26)+-14)==X6)==0))
// >= 0
// if ((E'%26)) != X6+14 then X6+10
// not possible unless C is 1.

F: (((((((((E'/26)*((25*((((E'%26)+-14)==X6)==0))+1))+E)*26)+(X7+6))*26)+(X8+1))*((25*((((X9+11)+-6)==X10)==0))+1))+((X10+9)*((((X9+11)+-6)==X10)==0)))
// (((((((((>=0)*(26 or 1))+E)*26)+(X7+6))*26)+(X8+1))*(26 or 1))+((X10+9)*(1 or 0)))
// >= 0
// (((((((((E'/26)*((25*((((E'%26)+-14)==X6)==0))+1))+E)*26)+(X7+6))*26)+(X8+1))*((25*(((X9+5)==X10)==0))+1))+((X10+9)*(((X9+5)==X10)==0)))

G: (((F/26)*((25*((((F%26)+-6)==X11)==0))+1))+((X11+14)*((((F%26)+-6)==X11)==0)))
// (F/26)*(26 or 1)+([15,23]*(1 or 0))

H: ((G/26)*((25*((((G%26)+-2)==X12)==0))+1))
// (G/26)*(26 or 1)
// We know that H < 25.

I: ((X12+11)*((((G%26)+-2)==X12)==0))
// I = 0 or [12,20]
// ([12,20]*((((G%26)+-2)==X12)==0))

End product: z:
(
(((H+I)/26)*((25*(((((H+I)%26)+-9)==X13)==0))+1))+
((X13+2)*(((((H+I)%26)+-9)==X13)==0))
)
=====================================
When would this equal 0?
Simplifying:

H+I < 25
AND
(((H+I)%26)+-9)==X13 => H+I==X13+9=[10,18]

Going up from H to A, we see that all these values are non-negative.
So the only way for z to be 0 is if all of these values are 0 as well.



=============================
Cheating!

What gates are there?
* (((X2+-8)==X3)==0)
* (((X4+-2)==X5)==0)
* (((X9+5)==X10)==0)

========================================

Substitution code v3
X'0: ((X0+8)*26) > 26
X'1: (X1+11) >= 12
X'2: ((X2+-8)!=X3) = [0,1]
X'3: ((X3+11)*X'2)
X'4: ((X4+-2)!=X5) = [0,1]
X'5: ((X5+5)*X'4)
X'6: ((((((((X'0+X'1)*((25*X'2)+1))+X'3)*((25*X'4)+1))+X'5)/26)*((25*((((((((X'0+X'1)*((25*X'2)+1))+X'3)*((25*X'4)+1))+X'5)%26)+-14)!=X6))+1))+((X6+10)*((((((((X'0+X'1)*((25*X'2)+1))+X'3)*((25*X'4)+1))+X'5)%26)+-14)!=X6))) = [9, 257] // Thank you smart compiler.
X'7: ((X'6*26)+(X7+6)) = [241, 6697]
X'8: ((X'7*26)+(X8+1)) = [6268, 174132]
X'9: ((X9+5)!=X10) = [0,1]
X'10: ((X'8*((25*X'9)+1))+((X10+9)*X'9)) = [6268,174142] // wow compiler
X'11: ((X11+14)*(((X'10%26)+-6)!=X11)) = 0 U [15, 23] // compiler says [0,15], so...must be 0 or 15. Since (X'10%26)+-6)==X11, 0.
XB'11: ((25*(((X'10%26)+-6)!=X11))+1) = {26, 1} // must be 1 to make lambda work
// (X'10%26)+-6)==X11
X'12: ((((((X'10/26)*XB'11)+X'11)%26)+-2)!=X12) = [0,1] // must be 0 to make lambda work

// λ = self.abstract_variables['z'].a1.m1.d1
λ: ((((((X'10/26)*XB'11)+X'11)/26)*((25*X'12)+1))+((X12+11)*X'12))

z:
(
((λ/26)*((25*(((λ%26)+-9)!=X13))+1))
+
((X13+2)*(((λ%26)+-9)!=X13))
)
---------------------------------
λ <= 25
(λ%26)==X13+9, therefore λ == X13+9 which means λ in [10, 18]
---------------------------------
λ = (X'10/26)/26, therefore X'10 in [6760, 12844]
----

